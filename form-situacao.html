<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Formulário de Situação (Agrupado por Categoria–Subcategoria)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="form-situacao_files/libs/clipboard/clipboard.min.js"></script>
<script src="form-situacao_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="form-situacao_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="form-situacao_files/libs/quarto-html/popper.min.js"></script>
<script src="form-situacao_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="form-situacao_files/libs/quarto-html/anchor.min.js"></script>
<link href="form-situacao_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="form-situacao_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="form-situacao_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="form-situacao_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="form-situacao_files/libs/bootstrap/bootstrap-bb462d781dde1847d9e3ccf7736099dd.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-full">

<main class="content column-page" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Formulário de Situação (Agrupado por Categoria–Subcategoria)</h1>
</div>



<div class="quarto-title-meta column-page">

    
  
    
  </div>
  


</header>


<style>
  /* Layout geral */
  .card { border: 1px solid #e5e7eb; border-radius: 14px; padding: 16px; margin: 12px 0; box-shadow: 0 2px 8px rgba(0,0,0,.04); }
  .row { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
  .stack { display: flex; flex-direction: column; gap: 8px; }
  .muted { color: #6b7280; font-size: .95rem; }
  .label { font-weight: 600; }
  textarea { width: 100%; min-height: 80px; }
  input[type="number"] { width: 140px; }
  .small { font-size: .9rem; }
  button { border: 1px solid #e5e7eb; background: #fff; padding: 8px 12px; border-radius: 10px; cursor: pointer; }
  button.primary { background: #111827; color: #fff; }

  /* Blocos por grupo (categoria-subcategoria), na vertical, sem scroll interno */
  .group-block { border: 1px solid #e5e7eb; border-radius: 12px; padding: 12px; margin: 10px 0; }
  .group-title { margin: 0 0 6px 0; font-size: 1.05rem; font-weight: 700; letter-spacing: .2px; }

  /* Duas linhas por grupo */
  .line-title { font-size: .9rem; font-weight: 600; margin: 6px 0 6px; color: #374151; }
  .chips { display: flex; flex-wrap: wrap; gap: 8px; }

  /* “Pílulas” (checkbox + nome) — sem mostrar número */
  .chip { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 9999px; cursor: pointer; user-select: none;
          border: 1px solid transparent; font-size: .92rem; }
  .chip input { appearance: none; width: 14px; height: 14px; border: 1.5px solid currentColor; border-radius: 3px; display: inline-block; position: relative; }
  .chip input:checked::after { content: ""; position: absolute; left: 2px; top: 2px; width: 8px; height: 8px; background: currentColor; border-radius: 2px; }

  /* Somente duas cores por tipo */
  .chip.O { color: #065f46; background: #e7f7ef; border-color: #bef0d2; }  /* Trafor (O) - verde */
  .chip.A { color: #7f1d1d; background: #fde8e8; border-color: #f9caca; }  /* Trafar (A)  - vermelho */
</style>

<div class="card">
  <h2 class="anchored">Parte 1 — Formulário</h2>
  <p class="muted">
    Grupos listados na vertical por <b>categoria–subcategoria</b>. Em cada grupo, <b>duas linhas</b>: Trafores (O) e Trafares (A).
    Apenas o <b>nome</b> do traço é exibido (sem número). Saída: <code>pergunta,pontuacao,trafores,trafares</code>.
  </p>

  <div class="row">
    <div class="stack">
      <label class="label" for="pergunta">Número da situação</label>
      <input id="pergunta" type="number" min="1" step="1" placeholder="ex.: 57">
    </div>
    <div class="stack">
      <label class="label" for="pontuacao">Pontuação (0–20)</label>
      <input id="pontuacao" type="number" min="0" max="20" step="1" placeholder="ex.: 4">
    </div>
  </div>

  <div class="stack" style="margin-top:12px;">
    <label class="label" for="descricao">Descrição da situação (opcional)</label>
    <textarea id="descricao" placeholder="Descreva a situação..."></textarea>
  </div>

  <div id="groups-vertical" aria-live="polite" style="margin-top:16px;"></div>

  <div class="small muted" style="margin-top:8px;">Dica: use <i>Ctrl/Cmd+F</i> para localizar traços rapidamente.</div>

  <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:12px;">
    <button class="primary" id="gerar">Gerar saída</button>
    <button id="limpar">Limpar seleção</button>
  </div>
</div>

<div class="card">
  <h2 class="anchored">Parte 2 — Saída</h2>

  <div class="stack">
    <div class="label">Linha CSV</div>
    <textarea id="csv-output" readonly="" placeholder="pergunta,pontuacao,trafores,trafares"></textarea>
    <div style="display:flex; gap:8px; flex-wrap:wrap;">
      <button id="copiar">Copiar CSV</button>
      <button id="baixar">Baixar CSV</button>
    </div>
  </div>

  <div class="stack" style="margin-top:12px;">
    <div class="label">Descrição textual</div>
    <div id="texto-output" class="small muted">A descrição aparecerá aqui.</div>
  </div>
</div>

<script>
/** CSV utils **/
function parseCSV(text) {
  const lines = text.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
  if (!lines.length) return [];
  const header = lines[0].split(",").map(h => h.trim().toLowerCase());
  return lines.slice(1).map(line => {
    const cols = line.split(",");
    const obj = {};
    header.forEach((h, i) => obj[h] = (cols[i] ?? "").trim());
    return obj;
  });
}
function csvEscapeField(s) {
  if (s == null) return "";
  const needsQuotes = /[",\n]/.test(s);
  let out = String(s).replace(/"/g, '""');
  return needsQuotes ? `"${out}"` : out;
}
function generateCSVLine({ pergunta, pontuacao, traforesIds, trafaresIds }) {
  const traforesStr = traforesIds.join(",");
  const trafaresStr = trafaresIds.join(",");
  return [
    csvEscapeField(pergunta),
    csvEscapeField(pontuacao),
    csvEscapeField(traforesStr),
    csvEscapeField(trafaresStr)
  ].join(",");
}
function downloadText(filename, content) {
  const blob = new Blob([content], { type: "text/csv;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = filename;
  document.body.appendChild(a); a.click();
  URL.revokeObjectURL(url); a.remove();
}

/** Agrupar por Categoria–Subcategoria (quando existir) e renderizar sem scrolls */
function renderGroups(container, data) {
  container.innerHTML = "";

  // Normalização
  const rows = data.map(r => ({
    id: String(r.id || "").trim(),
    tipo: String(r.tipo || "").trim().toUpperCase(),   // O/A
    nome: String(r.nome || "").trim(),
    categoria: String(r.categoria || "").trim().toUpperCase(),
    subcategoria: String(r.subcategoria || "").trim().toUpperCase()
  }));

  // Chave do grupo: CATEGORIA ou CATEGORIA-SUBCATEGORIA se houver subcategoria
  const keyOf = (row) => row.subcategoria ? `${row.categoria}-${row.subcategoria}` : row.categoria;

  // Construir dicionário de grupos
  const groups = {};
  rows.forEach(row => {
    const key = keyOf(row);
    if (!groups[key]) groups[key] = { O:[], A:[] };
    groups[key][row.tipo].push(row);
  });

  // Ordenação interna (alfabética por nome)
  Object.values(groups).forEach(g => {
    ["O","A"].forEach(t => g[t].sort((a,b)=>a.nome.localeCompare(b.nome,'pt',{sensitivity:'base'})));
  });

  // Ordem externa dos grupos (categoria base + três subcats da CONSCIENCIALIDADE)
  const desiredOrder = [
    "SOMA",
    "BIOENERGÉTICA",
    "ANTIEMOCIONALIDADE",
    "INVULGARIDADE",
    "LIDERANÇA",
    "COMUNICABILIDADE",
    "PRIORIZAÇÃO",
    "COERÊNCIA",
    "CONSCIENCIALIDADE-VOLIÇÃO_IDENTIDADE",
    "CONSCIENCIALIDADE-LUCIDEZ_ANÁLISE",
    "CONSCIENCIALIDADE-CONDUTA_CONVIVÊNCIA",
    "UNIVERSALIDADE"
  ];

  // Montar lista final de chaves respeitando desiredOrder e incluindo extras ao fim
  const keys = Object.keys(groups);
  const orderedKeys = [
    ...desiredOrder.filter(k => keys.includes(k)),
    ...keys.filter(k => !desiredOrder.includes(k)).sort((a,b)=>a.localeCompare(b,'pt',{sensitivity:'base'}))
  ];

  // Render
  orderedKeys.forEach(key => {
    const g = groups[key];
    if (!g) return;

    const wrap = document.createElement("div");
    wrap.className = "group-block";

    const h = document.createElement("div");
    h.className = "group-title";
    h.textContent = key; // Ex.: SOMA  /  CONSCIENCIALIDADE-VOLIÇÃO_IDENTIDADE
    wrap.appendChild(h);

    // Linha Trafores (O)
    const titleO = document.createElement("div");
    titleO.className = "line-title";
    titleO.textContent = "Trafores (O)";
    wrap.appendChild(titleO);

    const chipsO = document.createElement("div");
    chipsO.className = "chips";
    (g.O || []).forEach(item => {
      const lab = document.createElement("label");
      lab.className = "chip O";
      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.value = item.id;               // mantém id para saída
      cb.dataset.tipo = "O";
      cb.dataset.nome = item.nome;
      cb.dataset.categoria = item.categoria;
      const txt = document.createElement("span");
      txt.textContent = item.nome;      // sem número
      lab.appendChild(cb); lab.appendChild(txt);
      chipsO.appendChild(lab);
    });
    wrap.appendChild(chipsO);

    // Linha Trafares (A)
    const titleA = document.createElement("div");
    titleA.className = "line-title";
    titleA.textContent = "Trafares (A)";
    wrap.appendChild(titleA);

    const chipsA = document.createElement("div");
    chipsA.className = "chips";
    (g.A || []).forEach(item => {
      const lab = document.createElement("label");
      lab.className = "chip A";
      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.value = item.id;
      cb.dataset.tipo = "A";
      cb.dataset.nome = item.nome;
      cb.dataset.categoria = item.categoria;
      const txt = document.createElement("span");
      txt.textContent = item.nome;
      lab.appendChild(cb); lab.appendChild(txt);
      chipsA.appendChild(lab);
    });
    wrap.appendChild(chipsA);

    container.appendChild(wrap);
  });
}

function getSelections() {
  const checked = Array.from(document.querySelectorAll('#groups-vertical input[type="checkbox"]:checked'));
  const trafores = [], trafares = [], namesO = [], namesA = [];
  checked.forEach(cb => {
    const id = parseInt(cb.value, 10);
    const tipo = cb.dataset.tipo;
    const nome = cb.dataset.nome;
    if (tipo === "O") { trafores.push(id); namesO.push(nome); }
    else { trafares.push(id); namesA.push(nome); }
  });
  trafores.sort((a,b)=>a-b);
  trafares.sort((a,b)=>a-b);
  return { trafores, trafares, namesO, namesA };
}

/** App */
(async function main(){
  const container = document.getElementById("groups-vertical");
  const csvOut = document.getElementById("csv-output");
  const textoOut = document.getElementById("texto-output");
  const perguntaEl = document.getElementById("pergunta");
  const pontuacaoEl = document.getElementById("pontuacao");
  const descricaoEl = document.getElementById("descricao");

  // Carrega data/tracos.csv (atualizado com 'subcategoria' para CONSCIENCIALIDADE)
  let data = [];
  try {
    const res = await fetch("data/tracos.csv", { cache: "no-store" });
    if (!res.ok) throw new Error("HTTP " + res.status);
    const txt = await res.text();
    data = parseCSV(txt);
  } catch(e) {
    console.warn("Falha em data/tracos.csv, usando fallback de exemplo:", e);
    data = [
      {id:"173",tipo:"O",nome:"Psicomotricidade",categoria:"SOMA",subcategoria:""},
      {id:"182",tipo:"O",nome:"Sanidade",categoria:"SOMA",subcategoria:""},
      {id:"183",tipo:"O",nome:"Saúde",categoria:"SOMA",subcategoria:""},
      {id:"42", tipo:"O",nome:"Clareza",categoria:"COMUNICABILIDADE",subcategoria:""},
      {id:"168",tipo:"A",nome:"Prolixidade",categoria:"COMUNICABILIDADE",subcategoria:""},
      {id:"1",  tipo:"O",nome:"Abnegação",categoria:"CONSCIENCIALIDADE",subcategoria:"VOLIÇÃO_IDENTIDADE"},
      {id:"14", tipo:"O",nome:"Analiticidade",categoria:"CONSCIENCIALIDADE",subcategoria:"LUCIDEZ_ANÁLISE"},
      {id:"5",  tipo:"O",nome:"Afabilidade",categoria:"CONSCIENCIALIDADE",subcategoria:"CONDUTA_CONVIVÊNCIA"},
    ];
  }

  renderGroups(container, data);

  document.getElementById("gerar").addEventListener("click", () => {
    const pergunta = parseInt(perguntaEl.value, 10);
    const pontuacao = parseInt(pontuacaoEl.value, 10);

    if (!Number.isInteger(pergunta) || pergunta < 1) {
      alert("Informe um número de situação válido (inteiro >= 1).");
      return;
    }
    if (!Number.isInteger(pontuacao) || pontuacao < 0 || pontuacao > 20) {
      alert("Pontuação deve ser um inteiro entre 0 e 20.");
      return;
    }

    const { trafores, trafares, namesO, namesA } = getSelections();
    const line = generateCSVLine({ pergunta, pontuacao, traforesIds: trafores, trafaresIds: trafares });

    csvOut.value = "pergunta,pontuacao,trafores,trafares\n" + line;

    const descrTrafores = namesO.length ? namesO.join(", ") : "—";
    const descrTrafares = namesA.length ? namesA.join(", ") : "—";
    textoOut.textContent = `Para: pergunta número ${pergunta}, pontuação ${pontuacao}, trafores ${descrTrafores} e trafares ${descrTrafares}.`;
  });

  document.getElementById("limpar").addEventListener("click", () => {
    perguntaEl.value = ""; pontuacaoEl.value = ""; descricaoEl.value = "";
    document.querySelectorAll('#groups-vertical input[type="checkbox"]').forEach(el => el.checked = false);
    csvOut.value = ""; textoOut.textContent = "A descrição aparecerá aqui.";
  });

  document.getElementById("copiar").addEventListener("click", async () => {
    const v = csvOut.value.trim();
    if (!v) { alert("Nada para copiar ainda."); return; }
    try { await navigator.clipboard.writeText(v); alert("CSV copiado."); }
    catch { alert("Não foi possível copiar automaticamente. Copie manualmente."); }
  });

  document.getElementById("baixar").addEventListener("click", () => {
    const v = csvOut.value.trim();
    if (!v) { alert("Nada para baixar ainda."); return; }
    downloadText("situacao.csv", v + "\n");
  });
})();
</script>

<script>
// Alfabeto Base58 (Bitcoin): sem 0 O I l
const B58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";

// Random bytes via Web Crypto
function randomBytes(n = 8) { // 8 bytes ≈ 64 bits de entropia
  const a = new Uint8Array(n);
  crypto.getRandomValues(a);
  return a;
}

// Converte BigInt -> Base58
function toBase58BigInt(n) {
  if (n === 0n) return "1"; // '1' representa zero em Base58
  let s = "";
  while (n > 0n) {
    const r = n % 58n;
    s = B58[Number(r)] + s;
    n = n / 58n;
  }
  return s;
}

// Gera um short aleatório Base58 com tamanho fixo (default 10 chars)
function base58RandomShort(len = 10) {
  // 8 bytes (64 bits) codificados em Base58 geram ~11 chars; cortamos/padronizamos para len
  const bytes = randomBytes(8);
  let n = 0n;
  for (const b of bytes) n = (n << 8n) | BigInt(b);
  const enc = toBase58BigInt(n);
  // pad à esquerda com '1' (zero Base58) e corta para o tamanho desejado
  const padded = enc.length >= len ? enc : "1".repeat(len - enc.length) + enc;
  return padded.slice(0, len);
}

// YYMMDD a partir do ISO (interpretado como horário local do navegador)
function yymmddFromISO(iso) {
  const d = new Date(iso);
  if (isNaN(d)) throw new Error("Data ISO inválida. Use 'YYYY-MM-DDTHH:MM:SS'.");
  const yy = String(d.getFullYear() % 100).padStart(2, "0");
  const mm = String(d.getMonth() + 1).padStart(2, "0");
  const dd = String(d.getDate()).padStart(2, "0");
  return `${yy}${mm}${dd}`;
}

// ID final: SITU-YYMMDD-short
function makeSituIdFromISO(iso, shortLen = 6) {
  const ymd = yymmddFromISO(iso);
  const short = base58RandomShort(shortLen);
  return `SITU-${ymd}-${short}`;
}

// --- exemplos ---
// console.log(makeSituIdFromISO("2025-09-04T14:23:01"));       // SITU-250904-xxxxxxxxxx
// console.log(makeSituIdFromISO("2025-09-04T14:23:01", 8));    // SITU-250904-xxxxxxxx
</script>


</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>